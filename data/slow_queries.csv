query_id,sql_text,execution_time_sec,rows_processed,cost,disk_reads,buffer_gets,executions,parse_calls,first_load_time,issue,recommendation
Q001,SELECT * FROM orders WHERE order_date > '2023-01-01' ORDER BY order_id,45.2,1500000,5000,12000,45000,5,5,2024-12-01/10:30:00,Full table scan,Créer un index sur order_date et utiliser WHERE avec plage spécifique
Q002,"SELECT c.*, o.* FROM customers c JOIN orders o ON c.id = o.customer_id WHERE c.country = 'USA'",38.7,850000,4200,8500,52000,12,12,2024-11-15/14:22:00,Nested loops join inefficient,Utiliser HASH JOIN avec hint /*+ USE_HASH(c o) */ et index sur customers.country
Q003,SELECT DISTINCT product_name FROM products WHERE category LIKE '%elect%' AND price > 100,29.3,500000,3500,4500,38000,8,8,2024-12-10/09:15:00,LIKE avec wildcard initial,Utiliser Oracle Text Search ou réécrire avec category LIKE 'elect%' si possible
Q004,UPDATE employees SET salary = salary * 1.1 WHERE department_id IN (SELECT id FROM departments WHERE active = 'Y'),52.1,75000,6800,9500,67000,1,1,2024-12-20/16:45:00,Subquery non optimisée dans IN clause,Remplacer par JOIN: UPDATE employees e SET salary = salary * 1.1 WHERE EXISTS (SELECT 1 FROM departments d WHERE d.id = e.department_id AND d.active = 'Y')
Q005,SELECT * FROM invoices WHERE YEAR(invoice_date) = 2024 AND status = 'PAID',41.8,1200000,4900,11000,42000,25,25,2024-11-05/11:30:00,Fonction sur colonne indexée,Réécrire sans fonction: invoice_date >= '2024-01-01' AND invoice_date < '2025-01-01' AND status = 'PAID'
Q006,"SELECT p.*, (SELECT COUNT(*) FROM orders WHERE product_id = p.id) as order_count FROM products p",67.4,320000,8200,15000,89000,3,3,2024-10-28/13:20:00,Scalar subquery dans SELECT,"Remplacer par LEFT JOIN: SELECT p.*, COUNT(o.id) as order_count FROM products p LEFT JOIN orders o ON p.id = o.product_id GROUP BY p.id, p.name, ..."
Q007,SELECT * FROM audit_logs ORDER BY timestamp DESC FETCH FIRST 1000 ROWS ONLY,33.6,2000000,5500,13000,48000,50,50,2024-12-12/08:45:00,Tri sur table volumineuse non indexée,"Créer index sur timestamp, utiliser pagination avec OFFSET-FETCH, partitionner la table"
Q008,"SELECT customer_id, SUM(amount) FROM payments WHERE status != 'CANCELLED' GROUP BY customer_id HAVING SUM(amount) > 10000",44.9,950000,5800,8900,51000,15,15,2024-11-22/15:10:00,Négation dans WHERE + aggregation,"Utiliser IN ('PAID', 'PENDING') et créer index couvrant (status, customer_id, amount)"
Q009,"WITH cte AS (SELECT * FROM transactions WHERE trans_date > ADD_MONTHS(SYSDATE, -6)) SELECT * FROM cte WHERE amount > (SELECT AVG(amount) FROM cte)",58.3,1800000,7200,14000,75000,7,7,2024-12-05/10:05:00,CTE réutilisé avec agrégation,Calculer la moyenne dans un sous-select séparé ou matérialiser la CTE
Q010,"SELECT d.dept_name, e.emp_name, e.salary FROM departments d CROSS JOIN employees e WHERE e.salary > 50000 AND d.location = 'HQ'",49.7,2500000,6100,16500,92000,2,2,2024-11-30/17:25:00,CROSS JOIN inutile,"Utiliser JOIN approprié avec condition, ou revoir la logique métier si CROSS JOIN est vraiment nécessaire"
